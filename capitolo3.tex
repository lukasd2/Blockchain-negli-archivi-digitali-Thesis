\chapter{Progetto di Archivi Digitali}
\label{ch:archivi}

Questo capitolo contiene la documentazione del progetto realizzato utilizzando le tecnologie descritte nei capitoli precedenti. Si tratta di un’applicazione decentralizzata costruita attraverso la blockchain pubblica Ethereum e il protocollo IPFS. Lo scopo principale di questo progetto è la descrizione della metodologia di sviluppo in un ecosistema distribuito. Se per molti programmatori imparare un nuovo linguaggio di programmazione o framework può essere una situazione frequente, lo sviluppo in un paradigma differente richiede una descrizione più approfondita della metodologia e delle pratiche migliori da adottare durante la fase di preparazione e di sviluppo.

\section{Definizione di obiettivi e requisiti dell’applicazione}

L’obiettivo dell'applicazione consiste nello sviluppo di un registro contenete opere d’arte definibili come minori che, potranno essere memorizzate in maniera trasparente, permanente e immutabile in una blockchain pubblica.

In dettaglio l’applicazione deve soddisfare i seguenti requisiti e funzionalità:

\begin{itemize}
\item Inserimento di oggetti nell’archivio attraverso l’utilizzo di sistemi di metadati adatti alla descrizione delle risorse da inserire.
\item Memorizzazione e visualizzazione degli oggetti inseriti.
\item Presenza di una categoria di utenti dotati di permessi di verifica dei dati inseriti nel sistema e approvazione degli oggetti inseriti attraverso un sistema di votazione.
\item Possibilità di modificare l’oggetto inserito da parte del suo autore mantenendo la storia completa delle modifiche effettuate.
\end{itemize}

Tenendo in mente questi requisiti e le considerazioni fatte nel capitolo \ref{sectionDigitalArchives}: "Blockchain negli archivi digitali" è possibile procedere con l'implementazione basata sulla blockchain Ethereum.

\subsection{Sistemi di metadati}

Prima di proseguire con la fase dello sviluppo dell'applicazione una considerazione importante riguarda la descrizione delle risorse attraverso sistemi di metadati. Secondo una descrizione generica: “i metadati sono informazioni strutturate relative ai dati, interpretabili da parte di un computer”\footfullcite{metadatiCNR}. Inserire un oggetto dentro un archivio digitale che gestisce opere d’arte minori implica l'implementazione di un sistema di regole adatto a esprimere le diverse tipologie delle risorse in questione. Ad esempio, le risorse da rappresentare possono essere dei manoscritti, delle fotografie, dei disegni, degli oggetti di oreficeria e così via.

Esistono molti standard più o meno formali per la descrizione di particolari categorie di materiale digitale, per questo progetto si è scelto di implementare tre modalità di rappresentazione delle risorse, le prime due appartengono allo schema di metadati Dublin Core\footfullcite{dublinCore}, mentre la terza è un esempio del modello ontologico CIDOC Conceptual Reference Model (CRM)\footfullcite{cidocCRM}.

La scelta è stata fatta tenendo conto dei diversi fattori a partire dal vasto insieme di tipologie a cui possono appartenere gli oggetti dell'archivio, è importante sopratutto trovare un compromesso tra la complessità della descrizione, la facilità di utilizzo per un utente non esperto in materia e il grado di precisione del sistema utilizzato. Per questo l’utente può scegliere tra tre modalità di inserimento, dal più semplice al più complesso. Dublin Core fornisce uno schema di meta informazioni ideato per assegnare etichette ragionevoli interessanti per qualunque materiale digitale. È uno schema flessibile, semplice ed estendibile che si presta bene alla costruzione di form adatte per la maggior parte dei casi di utilizzo previsti.

In figura \ref{fig:progettoInserimento} è rappresentata una parte della finestra contenente il modulo di inserimento con le relative scelte implementato nel progetto.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{immagini/inserimentoArchivio.PNG}
\caption{Progetto: Modulo inserimento nell'archivio}
\label{fig:progettoInserimento}
\end{figure}

La prima opzione, "Dublin Core", fornisce quindici etichette base per la descrizione delle risorse. La seconda opzione, "Dublin Core Esteso", permette una descrizione più approfondita della risorsa attraverso l'uso di qualificatori (o sottoclassi) che permettono un raffinamento dello schema con l'aggiunta di significati più precisi sui termini base. Infine la terza opzione, "CIDOC", è rivolta agli "esperti" in quanto fornisce un modello ontologico formale incentrato sulla rappresentazione semantica delle risorse.

Un ultima considerazione pratica riguarda le linee guida per la descrizione di beni culturali, fornite dal nucleo carabinieri per la tutela del patrimonio culturale in figura \ref{fig:carabinieriTPC}.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{immagini/carabinieriTPC2.png}
\caption{Beni culturali illecitamente sottratti: Modulo descrittivo}
\label{fig:carabinieriTPC}
\end{figure}

Il modulo Object ID\footfullcite{tpcCarabinieri} consente la descrizione di beni culturali ed è utile per le operazioni di recupero in caso di furto di tali beni. Idealmente quando la tecnologia sarà sufficientemente matura e testata, l'approvazione degli oggetti inseriti tramite un'applicazione basata sulla blockchain, potrebbe essere fatta dai membri autorizzati del Comando Carabinieri. Chiaramente il fatto di poter contare su una base di dati immutabile, permanente e dotata di storia completa fornirebbe dei vantaggi rilevanti rispetto ai sistemi attualmente in uso.

Con questo progetto si vuole dimostrare che è possibile adottare qualunque schema di descrizione in maniera relativamente semplice e quindi fornire una prova attendibile del possesso di tali beni. Mentre queste considerazioni sono state fatte tenendo in mente l'obiettivo consistente nella dimostrazione della metodologia, nel caso di un’applicazione pronta ad essere adottata al pubblico, questa parte assumerebbe un ruolo di primo piano per l'intero processo di sviluppo.

\section{Preparazione dell'ambiente di sviluppo}

Lo sviluppo del progetto sulla blockchain Ethereum è accompagnato dalla presenza di numerosi strumenti, in questa sezione sarà fornita la lista dei principali strumenti e delle dipendenze utilizzate durante la programmazione.

\begin{itemize}
\item NPM (Node Package Manager) per la gestione e l'installazione dei moduli/librerie Javascript. NPM richiede la presenza di Node.js\footnote{In questo progetto si è utilizzato Node.js nella versione 10.8.0 e NPM versione 6.2.0}.

\item Truffle framework (versione 4.1.14)\footfullcite{truffleFramework} un ambiente di sviluppo composto da un insieme di strumenti che facilitano la creazione delle applicazioni decentralizzate (di seguito dApps) sulla piattaforma Ethereum. Truffle gestisce il ciclo di migrazione (sulla blockchain) degli smart contracts, la loro integrazione ed esecuzione con la possibilità di eseguire test automatizzati.

Il framework include Ganache\footfullcite{ganache} (versione 1.2.2), una blockchain personale, utile per lo sviluppo locale delle dApps. Ganache è un emulatore di nodi Ethereum con un'interfaccia grafica intuitiva (in figura {\ref{fig:ganache}}), mette a disposizione un certo numero di account precaricati con Ether. Si tratta di una blockchain con un funzionamento semplificato che permette di analizzare lo stato della blockchain in qualunque momento dell'esecuzione.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{immagini/ganache-window.png}
\caption{Ganache: Blockchain locale}
\label{fig:ganache}
\end{figure}

Truffle fornisce anche il codice \emph{boilerplate} ragruppato in diversi pacchetti chiamati "boxes" utili per uno sviluppo accelerato\footnote{Come base di questo progetto si è scelto il pacchetto chiamato pet-shop disponibile su https://truffleframework.com/boxes/pet-shop}.

\item Geth\footfullcite{geth} è l'implementazione ufficiale di un nodo completo Ethereum che permette la sincronizzazione e la partecipazione alla blockchain Ethereum.

\item Mocha e Chai sono usati per la costruzione e l'esecuzione di test automatizzati. Mocha\footfullcite{mocha} è un test framework per Javascript basato su Node.js, mentre Chai\footfullcite{chai} è una libreria di asserzioni che può essere implementata sul framework. Insieme permettono l'implementazione di test automatizzati complessivi secondo un approccio TDD (Test Driven Development) e BDD (Behaviour Driven Development).

\item Metamask\footfullcite{metamask} è un’estensione, disponibile per i maggiori browser (Firefox, Brave, Chrome ecc.). Necessario per utilizzare le dApps fornisce un portafoglio che consente di identificare l'utente (attraverso la chiave privata) e di gestire le transazioni.

\item Web3.js\footfullcite{web3} è una collezione di librerie che, attraverso un API, permette l'interazione con il codice dei contratti situati sulla blockchain. In particolare permette di sviluppare la parte client dell'applicazione con le chiamate di lettura e di scrittura ai contratti.

\end{itemize}

Questi sono gli elementi più importanti, al momento più usati per interagire con le dApps e sviluppare le proprie applicazioni. Altri elementi scelti per lo sviluppo di questa specifica applicazione, nella maggior parte opzionali, verranno introdotti in seguito.

\section{Sviluppo dell'applicazione}

Lo sviluppo dell'applicazione può essere suddiviso in due fasi distinte:

\begin{itemize}

\item La prima fase si pone come obiettivo la creazione di un \emph{Minimal Viable Product} (MVP) cioè un prototipo che  implementata le funzionalità base del progetto. Consiste principalmente nello sviluppo dei contratti, l'esecuzione di test e costruzione di una interfaccia base (GUI) che permette l'interazione con i contratti in un contesto di sviluppo locale.

\item Nella seconda fase si estendono le funzionalità di base in modo da implementare nuove funzionalità e costruire la versione finale. Consiste principalmente nell'integrazione con il servizio di storage IPFS, lo sviluppo della parte front-end finale e il trasferimento dei contratti su una blockchain Ethereum di sviluppo (\emph{testnet}).

\end{itemize}

\subsection{Scrittura dei Contratti}

Gli smart contracts scritti in Solidity costituiscono la parte back-end e contengono la logica dell'applicazione. Nel contratto principale, \emph{Archives.sol}, tra le prime operazioni si definisce la struttura degli oggetti da inserire sulla blockchain.
\\
\begin{lstlisting}[caption={Struttura degli oggetti},language=JavaScript]
struct Artwork {
    uint id; //identificatore univoco
    address author; //indirizzo dell'autore
    string name; //nome o titolo dell'oggetto
    string descriptionHash; //descrizione completa dell'oggetto
    string dataHash; //immagine rappresentativa dell'oggetto
    bool validation; //stato dell'approvazione (true o false)
    uint votesNum; //numero delle approvazioni (o voti)
}
\end{lstlisting}

Le caratteristiche degli oggetti sono definite tramite una variabile "Artwork" di tipo \emph{struct} cioè un tipo complesso definito dall'utente contenente al suo interno un insieme di proprietà che definiscono l'oggetto. Il passo successivo consiste nella costruzione di una sequenza di oggetti da memorizzare sulla blockchain. In Solidity è possibile costruire una sequenza composta da coppie chiave-valore (come in un array associativo) usando il tipo \emph{mapping}.
\\
\begin{lstlisting}[caption={Associazione chiave-valore},language=JavaScript]
mapping (uint => Artwork) public artworks;
uint artworkCounter; //contatore degli oggetti inseriti 
\end{lstlisting}

In questo modo mapping crea una specie\footfullcite{solidityMapping} di tabella hash (inizialmente vuota\footnote{In realtà è impossibile determinare a priori la dimensione del mapping o eseguire direttamente delle iterazioni sugli elementi. Questo perché tutte le chiavi restituiranno un valore di default, in questo caso di tipo Artwork.}) composta da un indice univoco (uint) che si riferisce a un oggetto di tipo Artwork. Ogni volta che verrà eseguito un assegnamento di chiave-valore, il risultato sarà memorizzato sulla blockchain. Le tabelle hash sono una struttura dinamica e pertanto è necessario tenere una variabile di stato contatore in modo da tenere traccia degli oggetti effettivamente inseriti.

A questo punto analizzando il codice del contratto Archives.sol\footnote{https://github.com/lukasd2/Digital-Archives-dApp/blob/master/contracts/Archives.sol} sono state implementate le funzionalità descritte nella fase di definizione dei requisiti del progetto.
\\
\begin{lstlisting}[caption={Funzioni principali del contratto Archives.sol},language=JavaScript]
function publishArtwork(string _name, string _descriptionHash, 
                        string _dataHash) public {...}
function approveArtwork(uint _id) public onlyIfWhitelisted(
                        msg.sender) checkValidation(_id) {...}
function modifyArtworkDescription(uint _id, 
                        string _newDescriptionHash) public {...}
\end{lstlisting}

\begin{itemize}
\item La funzione "publishArtwork" gestisce l'inserimento di un nuovo oggetto nell'archivio.
\item La funzione "approveArtwork" gestisce l'approvazione degli oggetti inserti. Permette agli utenti autorizzati di votare per un dato oggetto e di controllare se il numero di voti registrati è sufficiente alla sua approvazione.
\item La funzione "modifyArtworkDescription" permette all'utente che inserisce l'oggetto di modifcare la sua descrizione.
\end{itemize}

Successivamente al contratto Archives.sol sono stati aggiunti altri contratti che espandono le funzionalità e i controlli richiesti dall'applicazione. Per la costruzione della struttura dei contratti si è sfruttato il meccanismo dell'ereditarietà di Solidity con la gerarchia rappresentata in figura \ref{fig:contractStructure}. Archives.sol si trova al livello più alto della catena e dunque può usufruire di tutte le funzioni definite nei contratti situati a livello più basso. In particolare i contratti Whitelist.sol, RBAC.sol e Roles.sol sono usati rispettivamente per aggiungere indirizzi alla lista di utenti dotati di permessi di verifica e per gestire i permessi degli utenti che acquistano lo status di "artwork checker" con i rispettivi controlli.
Il contratto Ownable.sol implementa il meccanismo di autorizzazione dell'autore del contratto, cioè all'indirizzo che pubblica il contratto sulla rete. Nella versione attuale al "proprietario" vengono dati i permessi di aggiungere nuovi utenti alla whitelist. 

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{immagini/contractStructure.png}
\caption{Progetto: Struttura dei contratti}
\label{fig:contractStructure}
\end{figure}

Questi contratti (Whitelist.sol, Ownable.sol, RBAC.sol e Roles.sol) sono stati presi dalla libreria OpenZeppelin\footfullcite{openZeppelin} contenente implementazioni delle funzionalità ricorrenti nelle dApps. Sono considerati sicuri perché ampiamente testati e aggiornati dalla comunità, questi contratti sono stati opportunamente modificati e integrati in questo progetto{\footnote{Codice di tutti i contratti implementati, https://github.com/lukasd2/Digital-Archives-dApp/tree/master/contracts}}.

\subsection{Test dei Contratti}

Una volta implementata la logica dell'applicazione è particolarmente importante assicurarsi che i contratti siano sicuri e privi di errori eseguendo dei test automatici. Gli smart contracts una volta pubblicati su Ethereum diventano immutabili, ai contratti verrà assegnato un certo indirizzo sulla blockchain e non sarà più possibile effettuare delle modifiche al loro codice. 

Un altro aspetto importante riguarda i costi legati alla loro pubblicazione, le nuove versioni dell'applicazione possono essere pubblicate sotto nuovi indirizzi e ogni volta sarà necessario pagare, ex novo, il prezzo (Gas) calcolato per la loro pubblicazione. Un discorso analogo può essere fatto per i costi legati alle singole transazioni del contratto, l'obiettivo ideale è quello di creare una versione dell'applicazione ottimizzata e affidabile per i casi d'uso previsti dal programma e allo stesso tempo testata per prevenire comportamenti indesiderati.

In questa applicazione i programmi di testing sono stati divisi in tre parti (DigitalArchives\_initialState.js, DigitalArchives\_events.js e DigitalArchives\_exceptions.js{\footnote{Codice dei test automatizzati, https://github.com/lukasd2/Digital-Archives-dApp/tree/master/test}}). I programmi fanno uso della libreria di asserzioni Chai, nel primo gruppo viene controllato lo stato iniziale del contratto simulando una situazione al momento della pubblicazione sulla blockchain. Il secondo gruppo verifica l'esecuzione degli eventi e i comportamenti previsti al cambiamento dello stato in seguito alle transazioni. Infine il terzo gruppo riunisce un certo numero di scenari non permessi che l'applicazione dovrebbe gestire lanciando delle eccezioni.

Di seguito nella figura \ref{fig:contractTests} è mostrata l'esecuzione di questi test con Truffle e Ganache.
\\
\begin{lstlisting}[caption={Truffle esecuzione di test},language=JavaScript]
>> truffle test
\end{lstlisting}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{immagini/testContratti.png}
\caption{Progetto: Risultato esecuzione dei test}
\label{fig:contractTests}
\end{figure}


\subsection{Interazione client-side}

\subsection{Integrazione con IPFS}

\subsection{Costruzione dell'interfaccia}

\subsection{Ethereum Testnet}

\subsection{Considerazioni finali}


